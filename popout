import { Component, input, output, ElementRef, inject, signal, afterNextRender } from '@angular/core';

export interface PopoutSection {
  label: string;
  value: string;
}

export type PopoutPosition = 'top' | 'bottom' | 'left' | 'right' | 'auto';

@Component({
  selector: 'app-popout',
  standalone: true,
  template: `
    <div class="popout-wrapper">
      <div 
        class="info-popout" 
        [class]="'position-' + actualPosition()"
        (mouseenter)="mouseEnterPopup.emit()"
        (mouseleave)="mouseLeavePopup.emit()">
        @for (section of sections(); track section.label) {
          <div class="info-section">
            <span class="info-label">{{ section.label }}</span>
            <span class="info-value">{{ section.value }}</span>
          </div>
        }
      </div>
    </div>
  `,
  styles: `
    .popout-wrapper {
      position: relative;
      display: block;
    }

    .info-popout {
      position: absolute;
      z-index: 1000;
      min-width: 200px;
      padding: 12px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
      max-height: 300px;
      overflow-y: auto;
    }

    .position-bottom {
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-top: 8px;
    }

    .position-top {
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 8px;
    }

    .position-left {
      right: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-right: 8px;
    }

    .position-right {
      left: 100%;
      top: 50%;
      transform: translateY(-50%);
      margin-left: 8px;
    }

    .info-section {
      margin-bottom: 12px;
      display: flex;
      flex-direction: column;

      &:last-child {
        margin-bottom: 0;
      }
    }

    .info-label {
      font-weight: bold;
      margin-bottom: 4px;
      color: #333;
    }

    .info-value {
      color: #666;
      white-space: pre-line;
      line-height: 1.5;
      max-height: 100px;
      overflow-y: auto;
    }
  `
})
export class PopoutComponent {
  private readonly elementRef = inject(ElementRef);

  sections = input.required<PopoutSection[]>();
  position = input<PopoutPosition>('auto');

  mouseLeavePopup = output<void>();
  mouseEnterPopup = output<void>();

  actualPosition = signal<Exclude<PopoutPosition, 'auto'>>('bottom');

  constructor() {
    afterNextRender(() => {
      this.calculatePosition();
    });
  }

  private calculatePosition(): void {
    if (this.position() !== 'auto') {
      this.actualPosition.set(this.position() as Exclude<PopoutPosition, 'auto'>);
      return;
    }

    const wrapper = this.elementRef.nativeElement.querySelector('.popout-wrapper') as HTMLElement;
    const rect = wrapper.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    const spaceTop = rect.top;
    const spaceBottom = viewportHeight - rect.bottom;
    const spaceLeft = rect.left;
    const spaceRight = viewportWidth - rect.right;

    const spaces = {
      bottom: spaceBottom,
      top: spaceTop,
      right: spaceRight,
      left: spaceLeft
    };

    const bestPosition = (Object.entries(spaces) as [Exclude<PopoutPosition, 'auto'>, number][])
      .sort((a, b) => b[1] - a[1])[0][0];

    this.actualPosition.set(bestPosition);
  }
}




import { ComponentFixture, TestBed, fakeAsync, tick } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { PopoutComponent, PopoutSection } from './popout.component';
import { ComponentRef } from '@angular/core';

describe('PopoutComponent', () => {
  let component: PopoutComponent;
  let componentRef: ComponentRef<PopoutComponent>;
  let fixture: ComponentFixture<PopoutComponent>;

  const mockSections: PopoutSection[] = [
    { label: 'Primary: ', value: 'John Doe' },
    { label: 'Secondary: ', value: 'Jane Smith\nBob Smith' },
  ];

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PopoutComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(PopoutComponent);
    component = fixture.componentInstance;
    componentRef = fixture.componentRef;
  });

  describe('Position Logic', () => {
    it('should set actualPosition to the specified position when not auto', fakeAsync(() => {
      componentRef.setInput('sections', mockSections);
      componentRef.setInput('position', 'top');

      fixture.detectChanges();
      tick();

      expect(component.actualPosition()).toBe('top');
    }));

    it('should default actualPosition to bottom when position is auto', fakeAsync(() => {
      componentRef.setInput('sections', mockSections);
      componentRef.setInput('position', 'auto');

      fixture.detectChanges();
      tick();

      expect(['top', 'bottom', 'left', 'right']).toContain(component.actualPosition());
    }));
  });

  describe('Output Events', () => {
    it('should emit mouseEnterPopup on mouseenter event', fakeAsync(() => {
      componentRef.setInput('sections', mockSections);
      fixture.detectChanges();
      tick();

      let emitted = false;
      component.mouseEnterPopup.subscribe(() => {
        emitted = true;
      });

      const popout = fixture.debugElement.query(By.css('.info-popout'));
      popout.triggerEventHandler('mouseenter');

      expect(emitted).toBe(true);
    }));

    it('should emit mouseLeavePopup on mouseleave event', fakeAsync(() => {
      componentRef.setInput('sections', mockSections);
      fixture.detectChanges();
      tick();

      let emitted = false;
      component.mouseLeavePopup.subscribe(() => {
        emitted = true;
      });

      const popout = fixture.debugElement.query(By.css('.info-popout'));
      popout.triggerEventHandler('mouseleave');

      expect(emitted).toBe(true);
    }));
  });
});
